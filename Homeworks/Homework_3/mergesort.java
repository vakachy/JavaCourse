package Homeworks.Homework_3;

import java.util.Arrays;

class mergesort {

    // метод mergeSortIterative нужен для организации вызовов метода merge():
    // формирует аргументы, с которыми вызывается метод merge().
    // Сначала выбираются элементы начального массива "по два за раз".
    // Например, merge(a, 0, 1, 2); merge(a, 2, 3, 4); merge(a, 4, 5, 6)...
    // затем выбираются элементы начального массива "по четыре за раз".
    // Например, merge(a, 0, 2, 4); merge(a, 4, 6, 8); merge(a, 8, 10, 12)...
    // и т. д.
    public static void mergeSortIterative(int[] a) {
        int n = a.length;
        for (int i = 1; i < n; i *= 2) {
            for (int j = 0; j < n - i; j += 2 * i) {
                merge(a, j, j + i, Math.min(j + 2 * i, n)); // j+2*i может выйти за пределы массива
                                                            // метод Math.min() ограничит максимальное
                                                            // значение в таком случае длиной
                                                            // начального массива n
            }
        }
    }
    // метод merge():
    // 1. формирует вспомогательный массив
    // 2. сравнивает элементы подмассива, находящиеся на позициях "до половины" и "после половины" этого подмассива:
    // 3. сортирует эти элементы
    // 4. записывает в начальный массив в соответствующие позиции
    public static void merge(int[] a, int left, int mid, int right) {
        int it1 = 0; // переменные it1 и it2 отслеживают перемещение по
        int it2 = 0; // сортируемым в данный момент частям подмассива
        int[] result = new int[right - left]; // новый вспомогательный массив

        // пока не достигнута середина подмассива слева или не покинуты пределы подмассива справа
        // сравниваются значения элементов подмассива до середины с элементами этого подмассива после середины
        // меньший по значению записывается во вспомогательный массив
        while (left + it1 < mid && mid + it2 < right) {
            if (a[left + it1] < a[mid + it2]) {
                result[it1 + it2] = a[left + it1];
                it1 += 1;
            } else {
                result[it1 + it2] = a[mid + it2];
                it2 += 1;
            }
        }
        // "дозапись" оставшихся элементов в левой половине подмассива
        // в конец вспомогательного массива
        while (left + it1 < mid) {
            result[it1 + it2] = a[left + it1];
            it1 += 1;
        }
        // "дозапись" оставшихся элементов в правой половине подмассива
        // в конец вспомогательного массива
        while (mid + it2 < right) {
            result[it1 + it2] = a[mid + it2];
            it2 += 1;
        }
        // копируются элементы из вспомогательного массива в начальный массив
        for (int i = 0; i < it1 + it2; i++) {
            a[left + i] = result[i];
        }
    }
    public static void main(String[] args) {
        int[] a = { 0, 5, 10, 7, 3, 11, 6, -6, -6, -6 };
        System.out.println("Заданный массив:");
        System.out.println(Arrays.toString(a));
        mergeSortIterative(a);
        System.out.println("Массив после сортировки:");
        System.out.println(Arrays.toString(a));
    }
}